## დანართი ა: საკვანძო სიტყვები

მოცემული ჩამონათვალი შეიცავს საკვანძო სიტყვებს, რომლებსაც ხშირად გამოვიყენებთ Rust თან მუშაობის, ამ სიტყვებს ვერ გამოვიყენებთ როგორც საიდენტიფიკაციო ნიშნებად (გარდა გამონაკლისი შემთხვევებისა, მალევე განვიხილავთ “[Raw Identifiers][raw-identifiers]" სექციაში). საიდენტიფიკაციო ნიშნების მაგალითებია: ფუნქციების, პარამეტრების, მოდულების, კონსტანტების, მაკროების, ატრიბუტების, ტიპების და ასე შემდეგ სახელები, გთხოვთ იხილოთ ინგლისური ჩამონათვალი უკეთესად მიხვედრისათვის:

Identifiers are names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.

[raw-identifiers]: #raw-identifiers

### ამჟამინდელი საკვანძო სიტყვები

ქვევით ჩამოთვლილია საკვანძო სიტყვები, თავისივე ფუნქციური დახასიათებით, რომლებიც ამჟამად გამოიყენება:

- `as` - ოპერატორი საშუალებას გაძლევთ განახორციელოთ პრიმიტიული ტიპის კასტინგი (primitive casting), განსაზღვროთ კონკრეტული ტრეტი (trait), რომელიც შეიცავს რომელიმე ელემენტს, ან გამოიყენოთ use statement ში სახელების გადარქმევისათვის.

- `async` - აბრუნებს Future ობიექტს, რომელიც აღარ ბლოკავს მიმდინარე ნაკადს

- `await` - აჩერებს კოდის შესრულებას, სანამ `Future`-ის შედეგი მზად არ იქნება

- `break` - წყვეტს ციკლს დაუყოვნებლივ

- `const` - დეფინიცია გამოიყენება იმ ელემენტებისთვის ან ნედლი პოინტერებისთვის, რომელთა მნიშვნელობა კოდის გაშვებისას არ უნდა შეიცვალოს.

- `continue` - გადადის ციკლის შემდეგ იტერაციაზე

- `crate` - მოდულების გზის (module path) კონტექსტში, მიუთითებს მიმდინარე კრეიტის (crate) ძირეულ დონეზე (root level)

მაგალითად:

```text
// თუ გვაქვს ასეთი სტრუქტურა:

crate
 ├── src
 │   ├── main.rs
 │   └── utils
 │       └── helper.rs

// helper.rs-ში შეგვიძლია მივწვდეთ
// root მოდულში არსებულ ელემენტებს შემდეგნაირად:

use crate::some_root_function;
```

- `dyn` - დინამიური დისპატჩი trait ობიექტზე

- `if` - განშტოება, რომელიც დაფუძნებულია პირობითი გამოხატულების შედეგზე.

- `else` - გამოიყენება `if` და `if let` კონსტრუქციებში ალტერნატიული შემთხვევის დასამუშავებლად

- `enum` - განსაზღვრავს ჩამონათვალს (ენუმერაციას). ენუმერაცია არის ტიპი, რომელიც შეიძლება იყოს ერთ-ერთი წინასწარ განსაზღვრული ვარიანტებიდან. თითოეული ვარიანტი შეიძლება შეიცავდეს სხვადასხვა ტიპის მონაცემებს.

- `extern` - გამოიყენება გარე ფუნქციის ან ცვლადის დასაკავშირებლად

- `fn` - საკვანძო სიტყვა, რომელიც გამოიყენება ფუნქციის განსაზღვრისთვის ან ფუნქციის მაჩვენებლის (პოინტერის) ტიპის მითითებისთვის. უფრო მარტივად რომ ვთქვათ, იგი მიუთითებს ახალი ფუნქციის შექმნას ან ფუნქციაზე მიმთითებელ ცვლადს.

- `for` - გამოიყენება სამი მიზნით:

1. იტერატორიდან ელემენტებზე ციკლის შესასრულებლად
2. ტრეიტის იმპლემენტაციის აღსანიშნავად
3. უფრო მაღალი რანგის სასიცოცხლო ხანგრძლივობის (higher-ranked lifetime) მისათითებლად

- `impl` - გამოიყენება საკუთარი (inherent) ან ტრეიტის ფუნქციონალის იმპლემენტაციისთვის. სხვა სიტყვებით, იგი საშუალებას გვაძლევს განვსაზღვროთ ტიპის (მაგ. სტრუქტურის) მეთოდები და ასოცირებული ფუნქციები, ან განვახორციელოთ ტრეიტის მიერ განსაზღვრული ქცევა კონკრეტული ტიპისთვის.

- `in` - საკვანძო სიტყვა Rust-ში, რომელიც წარმოადგენს `for` ციკლის სინტაქსის ნაწილს. ის გამოიყენება იტერატორსა და ციკლის სხეულს შორის საზღვრის გასავლებად, რაც განსაზღვრავს თუ რომელ კოლექციაზე ან დიაპაზონზე უნდა მოხდეს იტერაცია.

- `let` - საკვანძო სიტყვა, რომელიც გამოიყენება ცვლადის გამოსაცხადებლად და მისთვის მნიშვნელობის მისანიჭებლად.

- `loop` - ციკლი, რომელიც არ სრულდება, პირობის არ ქონის გამო.

- `match` - აკავშირებს პატერნებს მნიშვნელობასთან

- `mod` - მოდულის დასადეკლარილებლად

- `move` - აიძულოს კლოჟურა (closure) მთლიანად დაეუფლოს (ანუ აიღოს მფლობელობა) იმ ცვლადებზე, რომლებსაც ის იყენებს.

- `mut` - გამოიყენება იმის მითითებისთვის, რომ მონაცემები შეიძლება შეიცვალოს.

- `pub` - გამოიყენება სტრუქტურების ველების, impl ბლოკების ან მოდულებისთვის, რათა მიუთითოს, რომ ისინი პროგრამის სხვა ნაწილებიდან ხელმისაწვდომია.

- `ref` - გამოიყენება ცვლადის მისამართით მიბმისთვის, რაც საშუალებას გვაძლევს შევცვალოთ ორიგინალური ცვლადის მნიშვნელობა ფუნქციის შიგნით.

- `return` - ფუნქციიდან მნიშვნელობის დაბრუნება

- `Self` - ტიპის ალიასი, რომელიც განსაზღვრავს ან იმპლემენტაციას უკეთებს ამჟამინდელ ტიპს.

- `self` - "მეთოდის მფლობელი" ან "მიმდინარე მოდული"

- `static` - ვარიანტი გლობალური ცვლადია, რომლის სიცოცხლის ციკლიც მთელი პროგრამის შესრულების განმავლობაში გრძელდება.

- `struct` - გამოიყენება მონაცემების უფრო რთული და მნიშვნელოვანი სტრუქტურების შესაქმნელად.

- `super` - მშობელი მოდული

- `trait` - trait - ის დასადეკლარილებლად

- `true` - Boolean
- `false` - Boolean

- `type` - გამოავლენს ტიპის ალიასი ან დაკავშირებულ ტიპს.

- `union` - გამოიყენება სინტაქსის კონკრეტულ კონსტრუქციაში, რომელიც ახალი გაერთიანების ტიპს ადგენს

- `unsafe` - არაუსაფრთხო კოდის, ფუნქციის ან იმპლემენტაციის გააქტიურება

- `use` - ბიბლიოთეკებიდან ფუნქციებისა და სტრუქტურების შემოტანა

- `where` - განსაზღვრავს დამატებით პირობებს, რომლებიც ტიპის მნიშვნელობებმა უნდა დააკმაყოფილონ

- `while` - ციკლი განმეორდება მანამ, სანამ განსაზღვრული პირობა სიმართლეს შეესაბამება

### სამომავნო საკვანძო სიტყვები

შემდეგი საკვანძო სიტყვები ჯერ არ აქვთ რაიმე ფუნქციონალი, მაგრამ დაცულია Rust-ის მიერ სამომავლო გამოყენებისთვის.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Raw Identifiers

_Raw identifiers_ - სინტაქცის ტიპები, რომლებიც საშვალებას გაძლევენ ზემოთ ჩამოთვლილი საკვანძო სიტყვები გამოიყენოთ, იქ სადაც ნორმალურ შემთხვევაში დასაშვები არ უნდა იყოს. ეს ყველაფერი საკვანძო სიტყვაზე თავსართის `r#` დამატებით ხდება

მაგალითად `match` - საკვანძო სიტყვა. როდესაც შეეცდები მომდევნო ფუნქციის დაკომპაილებას, რომლის სახელიც `match` ად არის დადეკლარირებული:

<span class="filename">ფაილის სახელი: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

მიიღებ ამგვარ ცდომილებას::

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

ეს ცდომილება იმის მაგალითია რომ შენ არ შეგიძლია საკვანძო სიტყვა - `match` - გამოიყენო ფუნქციის სახელად. Raw identifier ის სინტაქსი კი ამის საშვალებას მოგცემს, ამგვარად:

<span class="filename">ფაილის სახელი: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

ეს კოდი ყოველგვარი ცდომილებების გარეშე დაკომპაილდება. დაიმახსოვრე რომ თავსართი - `r#` - მხოლოდ ფუნქციის შექმნისას კიარა არამედ გამოძახებისასაც აუცილებელია.

Raw identifiers ნებას გრთავს გამოიყენო ნებისმიერი სიტყვა რომელსაც შენ აირჩევ, არ აქვს მნიშვნელობა ეს სიტყვა წინასწარ განსაზღვრულ საკვანძო სიტყვებშიც რომ შედიოდეს. ამგვარი მიდგომა უფრო მეტ თავისუფლებას გვაძლევს სახელების არჩევისას, ასევე

ასევე საშუალებას გვაძლევს ინტეგრაცია გავუწიოთ პროგრამებს, რომლებიც დაწერილია ისეთ ენაზე, სადაც ეს სიტყვები საკვანძო სიტყვებად არ ითვლება. გარდა ამისა, raw identifiers
raw identifiers საშუალებას გაძლევთ გამოიყენოთ ბიბლიოთეკები, რომლებიც დაწერილია სხვა Rust-ის ვერსიაში, ვიდრე თქვენი crate იყენებს. მაგალითად, `try` არ არის საკვანძო სიტყვა 2015 წლის ვერსიაში, მაგრამ არის 2018 წლის გამოცემაში. თუ თქვენ დამოკიდებული ხართ ბიბლიოთეკაზე, რომელიც დაწერილია 2015 წლის გამოცემით და აქვს `try` ფუნქცია, თქვენ უნდა გამოიყენოთ raw identifier სინტაქსი, ამ შემთხვევაში `r#try`, რათა გამოიძახოთ ეს ფუნქცია თქვენი 2018 წლის გამოცემის კოდიდან. იხილეთ [დანართი-ე][appendix-e] დამატებითი ინფორმაციისათვის.

[appendix-e]: appendix-05-editions.md
